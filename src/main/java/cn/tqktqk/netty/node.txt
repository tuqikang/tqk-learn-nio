<---------------------Buffer------------------------>
缓冲区Buffer:是一个对象，包含一些要写入或者读出的数据。在NIO中所有数据都是用缓冲区处理：
                                                从Channel进入Buffer，再从Buffer得到数据、写入是一样的：通过filp实现状态的翻转.
            读取数据时，直接读到缓存区，写入时，写入到缓存区，任何访问NIO中的数据都是通过缓存去进行操作
            实质上是一个数组，字节数组ByteBuffer，也可以使用其他种类的数组，但是不仅仅是个数组，缓冲区
            还提供了对数据的结构化访问以及维护读写位置（limit）等信息
            最常用的缓冲区：ByteBuffer，其实java8大基本数据类型都有一种缓冲区(除了Boolean)：CharBuffer、IntBuffer、DoubleBuffer....
            因为大多I/O操作都是用ByteBuffer，所以ByteBuffer除了一般的缓冲区还有一些特有的操作
            Buffer本身是一个内存，底层实际是一个数组。

            Buffer中的 : position limit capacity

            mark标记，reset就会回到mark的地方

            compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。
            limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。

            可以通过调用缓冲区的 asReadOnlyBuffer() 方法，将任何常规缓冲区转换为只读缓冲区，
            这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据)，只不过它是只读的

            直接字节缓冲区，Java 虚拟机将尽最大努力直接对它执行本机 I/O 操作。
            也就是说，它会在每一次调用底层操作系统的本机 I/O 操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中(或者从一个中间缓冲区中拷贝数据)。
            直接缓冲buffer: c/c++ malloc函数 buffer有个成员变量long address专门给dirtybuffer使用，指向堆外内存（直接内存）的地址，能直接找到数据。
            少了一次数据拷贝的过程，zero copy.回收时，会找到对应的address，然后jni会把该堆外内存回收

            底层new HeapByteBuffer() 位于堆，和普通对象没区别。实际多了一次数据拷贝的过程，会把java内存中的数据放在java外 native 堆中，然后和io设备进行操作
            ByteBuffer byteBuffer = ByteBuffer.allocate(10);

            内存映射文件创建直接缓冲区 --- MappedByteBuffer是一个文件的内存映射区域,表示这个文件的内容被映射到内存，我们只需要和内存打交道就行了，
            内容最后会被写回去磁盘
            MappedByteBuffer mbb = fc.map( FileChannel.MapMode.READ_WRITE,     0, 1024 );

            0<= mark <= position <= limit <= capacity

            rewind() 重新读

            buffer 不是 thread safe

<---------------------Channel------------------------>

通道Channel:通过它读取和写入数据，如同自来水管一样，网络数据通过Channel读取和写入。通道与流的不同之处在于通道是双向的，
            流只是一个方向上移动，而且通道可以用于读、写或者同时用于读写。
            因为是全双工的，所以它可以比流更好地映射底层操作系统的API。特别是UNIX网络编程模型种，底层操作系统的通道都
            是双全工的，同时支持读写操作。
            实际上可分为两大类-----用于读写的SelectableChannel和用于文件操作的FileChannel

<---------------------Selector------------------------>
多路复用器Selector:Java NIO编程的基础，功能：提供选择已经就绪的任务的能力。
                简单来说：Selector会不断地轮询注册在其上的Channel，如果某个Channel上面有新的TCP连接接入、读和写
                        事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就
                        绪状态Channel的集合，进行后续的I/O操作。
                 一个多路复用器可以同时轮询多个Channel，由于JDK使用epoll()代替传统的select实现，所以它并没有最大
                 连接句柄1024/2048的限制。这也就一位置只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端
